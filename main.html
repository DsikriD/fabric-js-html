<!DOCTYPE html>
<html>
<head>
    <title>Простая модель симуляции ткани (WebGPU)</title>
    <style>
        body { margin: 0; padding: 20px; background: #1a1a1a; color: white; font-family: Arial; }
        #canvas { width: 600px; height: 600px; border: 1px solid #333; }
        .controls { margin: 10px 0; }
        label { margin-right: 20px; }
    </style>
</head>
<body>
    <h1>Простая модель симуляции ткани (WebGPU)</h1>
    <div class="controls">
        <label><input type="checkbox" id="gravity"> Включить гравитацию</label>
    </div>
    <canvas id="canvas" width="600" height="600"></canvas>
    
    <script type="module">
        const canvas = document.getElementById('canvas');
        const gravityCheckbox = document.getElementById('gravity');
        
        // WebGPU setup
        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();
        const context = canvas.getContext('webgpu');
        const format = navigator.gpu.getPreferredCanvasFormat();
        context.configure({ device, format });
        
        // Создаем сетку 10x10 (WebGPU реализация)
        const rows = 10, cols = 10;
        const vertices = [];
        const indices = [];
        
        // Генерируем вершины
        for (let y = 0; y <= rows; y++) {
            for (let x = 0; x <= cols; x++) {
                vertices.push({
                    x: (x - cols/2) * 0.1,
                    y: 0,
                    z: (y - rows/2) * 0.1,
                    pinned: (x === 0 && y === 0) || (x === cols && y === 0) || 
                           (x === 0 && y === rows) || (x === cols && y === rows)
                });
            }
        }
        
         // Генерируем треугольники для mesh
         for (let y = 0; y < rows; y++) {
             for (let x = 0; x < cols; x++) {
                 const i = y * (cols + 1) + x;
                 const i1 = i + 1;
                 const i2 = i + cols + 1;
                 const i3 = i2 + 1;
                 
                 // Два треугольника на каждый квадрат
                 indices.push(i, i1, i2);   // Первый треугольник
                 indices.push(i1, i3, i2);  // Второй треугольник
             }
         }
         
         // Генерируем индексы для wireframe треугольников
         const wireframeIndices = [];
         for (let y = 0; y < rows; y++) {
             for (let x = 0; x < cols; x++) {
                 const i = y * (cols + 1) + x;
                 const i1 = i + 1;
                 const i2 = i + cols + 1;
                 const i3 = i2 + 1;
                 
                 // Линии первого треугольника
                 wireframeIndices.push(i, i1);   // горизонтальная
                 wireframeIndices.push(i1, i2);  // диагональная
                 wireframeIndices.push(i2, i);   // вертикальная
                 
                 // Линии второго треугольника
                 wireframeIndices.push(i1, i3);  // горизонтальная
                 wireframeIndices.push(i3, i2);  // вертикальная
                 wireframeIndices.push(i2, i1);  // диагональная
             }
         }
        
         // Создаем связи включая диагонали для предотвращения растяжения
         const springs = [];
         for (let y = 0; y <= rows; y++) {
             for (let x = 0; x <= cols; x++) {
                 const i = y * (cols + 1) + x;
                 
                 // Горизонтальные и вертикальные связи
                 if (x < cols) {
                     springs.push({a: i, b: i + 1, restLength: 0.1});
                 }
                 if (y < rows) {
                     springs.push({a: i, b: i + cols + 1, restLength: 0.1});
                 }
                 // Диагональные связи для предотвращения растяжения треугольников
                 if (x < cols && y < rows) {
                     springs.push({a: i, b: i + cols + 2, restLength: 0.141}); // диагональ
                     springs.push({a: i + 1, b: i + cols + 1, restLength: 0.141}); // обратная диагональ
                 }
             }
         }
        
         // Центральная точка для синуса
         const centerIndex = Math.floor(rows/2) * (cols + 1) + Math.floor(cols/2);
         console.log('Center index:', centerIndex, 'Total vertices:', vertices.length);
         console.log('Pinned vertices:', vertices.filter(v => v.pinned).length);
        
        // Создаем буферы
        const positions = new Float32Array(vertices.length * 4);
        const velocities = new Float32Array(vertices.length * 4);
        const pinnedMask = new Uint32Array(vertices.length);
        const springPairs = new Uint32Array(springs.length * 2);
        const restLengths = new Float32Array(springs.length);
        
        // Заполняем буферы
        for (let i = 0; i < vertices.length; i++) {
            const v = vertices[i];
            positions[i * 4] = v.x;
            positions[i * 4 + 1] = v.y;
            positions[i * 4 + 2] = v.z;
            positions[i * 4 + 3] = 0;
            velocities[i * 4] = 0;
            velocities[i * 4 + 1] = 0;
            velocities[i * 4 + 2] = 0;
            velocities[i * 4 + 3] = 0;
            pinnedMask[i] = v.pinned ? 1 : 0;
        }
        
        for (let i = 0; i < springs.length; i++) {
            springPairs[i * 2] = springs[i].a;
            springPairs[i * 2 + 1] = springs[i].b;
            restLengths[i] = springs[i].restLength;
        }
        
        // GPU буферы
        const posBuf = device.createBuffer({
            size: positions.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });
        device.queue.writeBuffer(posBuf, 0, positions);
        
        const posBuf2 = device.createBuffer({
            size: positions.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });
        device.queue.writeBuffer(posBuf2, 0, positions);
        
        const velBuf = device.createBuffer({
            size: velocities.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
        });
        device.queue.writeBuffer(velBuf, 0, velocities);
        
        const pinnedBuf = device.createBuffer({
            size: pinnedMask.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
        });
        device.queue.writeBuffer(pinnedBuf, 0, pinnedMask);
        
        const springsBuf = device.createBuffer({
            size: springPairs.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
        });
        device.queue.writeBuffer(springsBuf, 0, springPairs);
        
        const restLengthsBuf = device.createBuffer({
            size: restLengths.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
        });
        device.queue.writeBuffer(restLengthsBuf, 0, restLengths);
        
         const indicesBuf = device.createBuffer({
             size: indices.length * 4,
             usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
         });
         device.queue.writeBuffer(indicesBuf, 0, new Uint32Array(indices));
         
         const wireframeIndicesBuf = device.createBuffer({
             size: wireframeIndices.length * 4,
             usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
         });
         device.queue.writeBuffer(wireframeIndicesBuf, 0, new Uint32Array(wireframeIndices));
        
        const indicesStorageBuf = device.createBuffer({
            size: indices.length * 4,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
        });
        device.queue.writeBuffer(indicesStorageBuf, 0, new Uint32Array(indices));
        
         // Uniforms буфер
         const uniformSize = 20; // 5 floats
         const uniformBuf = device.createBuffer({
             size: uniformSize,
             usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
         });
        
        // WGSL шейдеры
        const shaderCode = `
        struct Uniforms {
            dt: f32,
            gravity: f32,
            time: f32,
            centerIndex: u32,
            amplitude: f32,
        }
        
        @group(0) @binding(0) var<storage, read_write> positions: array<vec4<f32>>;
        @group(0) @binding(1) var<storage, read_write> velocities: array<vec4<f32>>;
        @group(0) @binding(2) var<storage, read> pinnedMask: array<u32>;
        @group(0) @binding(3) var<uniform> uniforms: Uniforms;
        
        @group(1) @binding(0) var<storage, read> springPairs: array<vec2<u32>>;
        @group(1) @binding(1) var<storage, read> restLengths: array<f32>;
        @group(1) @binding(2) var<storage, read_write> springPositions: array<vec4<f32>>;
        @group(1) @binding(3) var<storage, read> springPinnedMask: array<u32>;
        
        @compute @workgroup_size(64)
        fn integrate(@builtin(global_invocation_id) gid: vec3<u32>) {
            let i = gid.x;
            if (i >= arrayLength(&positions)) { return; }
            
            if (pinnedMask[i] == 1u) {
                velocities[i] = vec4<f32>(0.0, 0.0, 0.0, 0.0);
                return;
            }
            
            var pos = positions[i].xyz;
            var vel = velocities[i].xyz;
            
            // Обновляем позицию
            pos += vel * uniforms.dt;
            
             // Движение центральной точки и передача соседним
             if (i == uniforms.centerIndex) {
                 // Плавно изменяющаяся амплитуда синуса
                 pos.y = uniforms.amplitude * sin(uniforms.time * 2.0);
             } else if (pinnedMask[i] == 0u) {
                 // Передача движения от центральной точки
                 let centerY = uniforms.amplitude * sin(uniforms.time * 2.0);
                 
                 let distance = length(pos - vec3<f32>(0.0, 0.0, 0.0)); // Расстояние от центра
                 var influence = max(0.0, 1.0 - distance * 2.5); // Умеренное затухание
                 
                 // Ограничиваем максимальное влияние для равномерности
                 let maxInfluence = 0.4;
                 influence = min(influence, maxInfluence);
                 
                 pos.y = centerY * influence * 0.25; // Передаем движение
             }
             
             // Ограничиваем максимальную скорость
             let maxVel = 5.0; // Увеличена максимальная скорость
             vel = clamp(vel, vec3<f32>(-maxVel), vec3<f32>(maxVel));
            
             // Демпфирование
             vel *= 0.99; // Меньше демпфирование для более заметного движения
            
            positions[i] = vec4<f32>(pos, 0.0);
            velocities[i] = vec4<f32>(vel, 0.0);
        }
        
        @compute @workgroup_size(64)
        fn solveSprings(@builtin(global_invocation_id) gid: vec3<u32>) {
            let i = gid.x;
            if (i >= arrayLength(&springPairs)) { return; }
            
            let pair = springPairs[i];
            let a = pair.x;
            let b = pair.y;
            
            if (springPinnedMask[a] == 1u && springPinnedMask[b] == 1u) { return; }
            
            let posA = springPositions[a].xyz;
            let posB = springPositions[b].xyz;
            let restLength = restLengths[i];
            
            let delta = posB - posA;
            let dist = length(delta);
            
                     if (dist > 0.0) {
                         let diff = dist - restLength;
                         let stiffness = 0.05; // Очень мягкая жесткость для равномерности
                         let force = stiffness * diff / dist;
                         var correction = force * delta;
                         
                         // Ограничиваем максимальное растяжение
                         let maxStretch = restLength * 1.2; // Максимум 120% растяжения
                         if (abs(diff) > maxStretch) {
                             correction = correction * (maxStretch / abs(diff));
                         }
                         
                         if (springPinnedMask[a] == 0u) {
                             springPositions[a] = vec4<f32>(posA + correction * 0.3, 0.0);
                         }
                         if (springPinnedMask[b] == 0u) {
                             springPositions[b] = vec4<f32>(posB - correction * 0.3, 0.0);
                         }
                     }
        }
        
        struct VSOut {
            @builtin(position) pos: vec4<f32>,
            @location(0) color: vec3<f32>,
        }
        
        @group(0) @binding(0) var<storage, read> drawPositions: array<vec4<f32>>;
        
        @vertex
        fn vs_main(@builtin(vertex_index) vid: u32) -> VSOut {
            let pos = drawPositions[vid].xyz;
            let scale = 0.8;
            var worldPos = vec4<f32>(pos.x * scale, pos.y * scale, pos.z * scale, 1.0);
            
            // 3/4 вид
            let ax = 0.9;
            let ay = -0.6;
            let cx = cos(ax); let sx = sin(ax);
            let cy = cos(ay); let sy = sin(ay);
            var v = worldPos.xyz;
            v = vec3<f32>(cy*v.x + sy*v.z, v.y, -sy*v.x + cy*v.z);
            v = vec3<f32>(v.x, cx*v.y - sx*v.z, sx*v.y + cx*v.z);
            
            var out: VSOut;
            out.pos = vec4<f32>(v.x, v.y - 0.1, 0.0, 1.0);
            
             out.color = vec3<f32>(0.6, 0.7, 0.8); // Светло-голубой цвет для треугольников
            return out;
        }
        
        @fragment
        fn fs_main(inFrag: VSOut) -> @location(0) vec4<f32> {
            return vec4<f32>(inFrag.color, 1.0);
        }
        
         @vertex
         fn vs_wireframe(@builtin(vertex_index) vid: u32) -> VSOut {
             let pos = drawPositions[vid].xyz;
             let scale = 0.8;
             var worldPos = vec4<f32>(pos.x * scale, pos.y * scale, pos.z * scale, 1.0);
             
             // 3/4 вид
             let ax = 0.9;
             let ay = -0.6;
             let cx = cos(ax); let sx = sin(ax);
             let cy = cos(ay); let sy = sin(ay);
             var v = worldPos.xyz;
             v = vec3<f32>(cy*v.x + sy*v.z, v.y, -sy*v.x + cy*v.z);
             v = vec3<f32>(v.x, cx*v.y - sx*v.z, sx*v.y + cx*v.z);
             
             var out: VSOut;
             out.pos = vec4<f32>(v.x, v.y - 0.1, 0.0, 1.0);
             out.color = vec3<f32>(0.3, 0.3, 0.3); // Темно-серый цвет для wireframe
             return out;
         }
         
         @group(0) @binding(2) var<storage, read> drawPinnedMask: array<u32>;
         @group(0) @binding(3) var<uniform> drawUniforms: Uniforms;
         
         @vertex
         fn vs_points(@builtin(vertex_index) vid: u32) -> VSOut {
             let pos = drawPositions[vid].xyz;
             let scale = 10.0;
             var worldPos = vec4<f32>(pos.x * scale * 10.0, pos.y * scale * 10.0, pos.z * scale * 10.0, 1.0);
             
             // 3/4 вид
             let ax = 0.9;
             let ay = -0.6;
             let cx = cos(ax); let sx = sin(ax);
             let cy = cos(ay); let sy = sin(ay);
             var v = worldPos.xyz;
             v = vec3<f32>(cy*v.x + sy*v.z, v.y, -sy*v.x + cy*v.z);
             v = vec3<f32>(v.x, cx*v.y - sx*v.z, sx*v.y + cx*v.z);
             
             var out: VSOut;
             out.pos = vec4<f32>(v.x, v.y, 0.0, 1.0);
             
             // Показываем только важные точки
             if (vid == drawUniforms.centerIndex) {
                 out.color = vec3<f32>(0.0, 0.0, 1.0); // Ярко-синий для центральной
                 out.pos.w = 5000.0; // Очень большой размер для центральной
             } else if (drawPinnedMask[vid] == 1u) {
                 out.color = vec3<f32>(1.0, 0.0, 0.0); // Ярко-красный для угловых
                 out.pos.w = 40.0; // Очень большой размер для угловых
             } else {
                 // Скрываем остальные точки
                 out.color = vec3<f32>(0.0, 0.0, 0.0);
                 out.pos.w = 0.0;
             }
             
             return out;
         }
        `;
        
        const shaderModule = device.createShaderModule({ code: shaderCode });
        
        // Bind group layouts
        const computeLayout0 = device.createBindGroupLayout({
            entries: [
                { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
            ]
        });
        
        const computeLayout1 = device.createBindGroupLayout({
            entries: [
                { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
            ]
        });
        
         const renderLayout = device.createBindGroupLayout({
             entries: [
                 { binding: 0, visibility: GPUShaderStage.VERTEX, buffer: { type: 'read-only-storage' } },
                 { binding: 1, visibility: GPUShaderStage.VERTEX, buffer: { type: 'read-only-storage' } },
                 { binding: 2, visibility: GPUShaderStage.VERTEX, buffer: { type: 'read-only-storage' } },
                 { binding: 3, visibility: GPUShaderStage.VERTEX, buffer: { type: 'uniform' } },
             ]
         });
        
        // Pipelines
        const integratePipeline = device.createComputePipeline({
            layout: device.createPipelineLayout({ bindGroupLayouts: [computeLayout0] }),
            compute: { module: shaderModule, entryPoint: 'integrate' }
        });
        
        const springsPipeline = device.createComputePipeline({
            layout: device.createPipelineLayout({ bindGroupLayouts: [computeLayout0, computeLayout1] }),
            compute: { module: shaderModule, entryPoint: 'solveSprings' }
        });
        
         const renderPipeline = device.createRenderPipeline({
             layout: device.createPipelineLayout({ bindGroupLayouts: [renderLayout] }),
             vertex: { module: shaderModule, entryPoint: 'vs_main' },
             fragment: { module: shaderModule, entryPoint: 'fs_main', targets: [{ format }] },
             primitive: { topology: 'triangle-list' }
         });
         
         const wireframePipeline = device.createRenderPipeline({
             layout: device.createPipelineLayout({ bindGroupLayouts: [renderLayout] }),
             vertex: { module: shaderModule, entryPoint: 'vs_wireframe' },
             fragment: { module: shaderModule, entryPoint: 'fs_main', targets: [{ format }] },
             primitive: { topology: 'line-list' }
         });
        
         const pointsPipeline = device.createRenderPipeline({
             layout: device.createPipelineLayout({ bindGroupLayouts: [renderLayout] }),
             vertex: { module: shaderModule, entryPoint: 'vs_points' },
             fragment: { module: shaderModule, entryPoint: 'fs_main', targets: [{ format }] },
             primitive: { topology: 'point-list' },
             render: {
                 alphaToCoverageEnabled: false,
                 antialias: false
             }
         });
        
        // Bind groups
        const computeGroup0 = device.createBindGroup({
            layout: computeLayout0,
            entries: [
                { binding: 0, resource: { buffer: posBuf } },
                { binding: 1, resource: { buffer: velBuf } },
                { binding: 2, resource: { buffer: pinnedBuf } },
                { binding: 3, resource: { buffer: uniformBuf } },
            ]
        });
        
        const computeGroup1 = device.createBindGroup({
            layout: computeLayout1,
            entries: [
                { binding: 0, resource: { buffer: springsBuf } },
                { binding: 1, resource: { buffer: restLengthsBuf } },
                { binding: 2, resource: { buffer: posBuf2 } },
                { binding: 3, resource: { buffer: pinnedBuf } },
            ]
        });
        
         const renderGroup = device.createBindGroup({
             layout: renderLayout,
             entries: [
                 { binding: 0, resource: { buffer: posBuf } },
                 { binding: 1, resource: { buffer: indicesStorageBuf } },
                 { binding: 2, resource: { buffer: pinnedBuf } },
                 { binding: 3, resource: { buffer: uniformBuf } },
             ]
         });
        
         // Animation loop
         let time = 0;
         let lastGravityState = false;
         let targetAmplitude = 0.5; // Целевая амплитуда
         let currentAmplitude = 0.5; // Текущая амплитуда
         function frame() {
             time += 1/60;
             
             // Плавное изменение амплитуды
             if (gravityCheckbox.checked) {
                 targetAmplitude = -1.0; // При включенной гравитации - уходим вниз (уменьшено в 2 раза)
             } else {
                 targetAmplitude = 0.5; // При выключенной гравитации - синус (уменьшено в 2 раза)
             }
             
             // Плавное изменение амплитуды со временем
             let amplitudeSpeed = 2.0; // Скорость изменения амплитуды
             let amplitudeDiff = targetAmplitude - currentAmplitude;
             currentAmplitude += amplitudeDiff * amplitudeSpeed * (1/60);
            
             // Update uniforms
             const uniforms = new Float32Array([
                 1/60, // dt
                 gravityCheckbox.checked ? 1.0 : 0.0, // gravity (включена/выключена)
                 time, // time
                 centerIndex, // centerIndex
                 currentAmplitude // amplitude
             ]);
            device.queue.writeBuffer(uniformBuf, 0, uniforms);
            
            // Compute passes
            const encoder = device.createCommandEncoder();
            
            // Integration
            const integratePass = encoder.beginComputePass();
            integratePass.setPipeline(integratePipeline);
            integratePass.setBindGroup(0, computeGroup0);
            integratePass.dispatchWorkgroups(Math.ceil(vertices.length / 64));
            integratePass.end();
            
            // Copy posBuf to posBuf2
            encoder.copyBufferToBuffer(posBuf, 0, posBuf2, 0, positions.byteLength);
            
             // Springs (20 iterations для равномерности)
             const springsPass = encoder.beginComputePass();
             springsPass.setPipeline(springsPipeline);
             springsPass.setBindGroup(0, computeGroup0);
             springsPass.setBindGroup(1, computeGroup1);
             for (let i = 0; i < 20; i++) {
                 springsPass.dispatchWorkgroups(Math.ceil(springs.length / 64));
             }
             springsPass.end();
            
            // Copy posBuf2 back to posBuf
            encoder.copyBufferToBuffer(posBuf2, 0, posBuf, 0, positions.byteLength);
            
            // Render
            const renderPass = encoder.beginRenderPass({
                colorAttachments: [{
                    view: context.getCurrentTexture().createView(),
                    clearValue: { r: 0.17, g: 0.18, b: 0.21, a: 1 },
                    loadOp: 'clear',
                    storeOp: 'store'
                }]
            });
            
             // Рендеринг треугольников
             renderPass.setPipeline(renderPipeline);
             renderPass.setBindGroup(0, renderGroup);
             renderPass.setIndexBuffer(indicesBuf, 'uint32');
             renderPass.drawIndexed(indices.length);
             
             // Рендеринг wireframe поверх треугольников
             renderPass.setPipeline(wireframePipeline);
             renderPass.setBindGroup(0, renderGroup);
             renderPass.setIndexBuffer(wireframeIndicesBuf, 'uint32');
             renderPass.drawIndexed(wireframeIndices.length);
             
             // Точки удалены
             
             renderPass.end();
            
            device.queue.submit([encoder.finish()]);
            requestAnimationFrame(frame);
        }
        
        frame();
    </script>
</body>
</html>
